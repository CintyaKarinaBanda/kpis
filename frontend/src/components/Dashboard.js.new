import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Grid, 
  Paper, 
  Typography, 
  CircularProgress,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Divider,
  useTheme,
  Button,
  Alert
} from '@mui/material';
import { 
  BarChart, 
  Bar, 
  LineChart, 
  Line, 
  PieChart, 
  Pie, 
  Cell,
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  Legend, 
  ResponsiveContainer,
  ReferenceLine,
  LabelList
} from 'recharts';
import { apiService } from '../services/serviceFactory';
import KPICard from './KPICard';

// Colores para gráficos
const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8', '#82ca9d'];

// Nombres más cortos para las categorías (para mostrar en gráficos)
const CATEGORY_SHORT_NAMES = {
  'Ventas por Tienda y Division': 'Ventas Tienda',
  'Ventas Presidencia': 'Ventas Pres.',
  'Operativo Diario': 'Op. Diario',
  'Indicadores Presidencia': 'Ind. Pres.',
  'Tendencia Firme / No Firme Ecommerce Outlet': 'Tendencias',
  'Ventas Viajes Palacio': 'Viajes',
  'Ventas Restaurantes': 'Restaurantes',
  'Operativo Mensual': 'Op. Mensual',
  'Operativo Fin de Semana y Semanal': 'Op. Semanal',
  'Operativo Anual': 'Op. Anual'
};

// Función para formatear fechas ISO a formato DD/MM/YYYY
const formatDate = (isoDate) => {
  if (!isoDate) return '';
  try {
    const date = new Date(isoDate);
    return `${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;
  } catch (e) {
    console.error('Error al formatear fecha:', e);
    return isoDate;
  }
};

const Dashboard = ({ userConfig }) => {
  const theme = useTheme();
  const [loading, setLoading] = useState(true);
  const [summary, setSummary] = useState(null);
  const [period, setPeriod] = useState('month');
  const [error, setError] = useState(null);
  const [visibleWidgets, setVisibleWidgets] = useState({
    kpiCards: true,
    trendChart: true,
    heatmap: true,
    barChart: true,
    pieChart: true
  });

  // Aplicar configuración de usuario
  useEffect(() => {
    if (userConfig && userConfig.dashboard && userConfig.dashboard.visibleWidgets) {
      const configWidgets = {};
      userConfig.dashboard.visibleWidgets.forEach(widget => {
        configWidgets[widget] = true;
      });
      setVisibleWidgets({
        kpiCards: false,
        trendChart: false,
        heatmap: false,
        barChart: false,
        pieChart: false,
        ...configWidgets
      });
    }
  }, [userConfig]);

  // Cargar datos según el período seleccionado
  useEffect(() => {
    loadData();
  }, [period]);

  const loadData = async () => {
    setLoading(true);
    setError(null);
    try {
      // Calcular fechas según el período
      const { startDate, endDate } = calculateDateRange(period);
      
      console.log(`Cargando datos de KPI desde ${startDate} hasta ${endDate}`);
      
      // Obtener datos de KPI
      const response = await apiService.getKPISummary(startDate, endDate);
      console.log('Datos de KPI recibidos:', response);
      
      if (response && response.summary) {
        // Asegurarse de que los datos de tendencia existan y tengan el formato correcto
        const processedSummary = {
          ...response.summary,
          trend: Array.isArray(response.summary.trend) ? response.summary.trend : []
        };
        
        // Asegurarse de que cada elemento de la tendencia tenga una fecha y tasa de cumplimiento
        if (processedSummary.trend.length > 0) {
          processedSummary.trend = processedSummary.trend.filter(item => item && item.date);
        }
        
        // Si no hay datos de tendencia, intentar generarlos a partir de byDate
        if (processedSummary.trend.length === 0 && processedSummary.byDate) {
          const trendFromByDate = Object.entries(processedSummary.byDate).map(([date, data]) => ({
            date,
            complianceRate: parseFloat(data.complianceRate || 0),
            ok: data.ok || 0,
            no: data.no || 0,
            na: data.na || 0
          }));
          
          if (trendFromByDate.length > 0) {
            processedSummary.trend = trendFromByDate;
          }
        }
        
        setSummary(processedSummary);
      } else {
        console.error('Respuesta de API incompleta:', response);
        setError('La respuesta de la API no contiene los datos esperados');
      }
    } catch (error) {
      console.error('Error al cargar datos del dashboard:', error);
      setError(`Error al cargar datos: ${error.message || 'Error desconocido'}`);
    } finally {
      setLoading(false);
    }
  };

  const calculateDateRange = (period) => {
    const endDate = new Date();
    let startDate = new Date();
    
    switch (period) {
      case 'week':
        startDate.setDate(endDate.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(endDate.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(endDate.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(endDate.getFullYear() - 1);
        break;
      default:
        startDate.setMonth(endDate.getMonth() - 1);
    }
    
    return {
      startDate: startDate.toISOString().split('T')[0],
      endDate: endDate.toISOString().split('T')[0]
    };
  };

  const handlePeriodChange = (event) => {
    setPeriod(event.target.value);
  };

  // Preparar datos para gráficos
  const prepareCategoryData = () => {
    if (!summary || !summary.byCategory) {
      console.log('No hay datos de categoría disponibles');
      return [];
    }
    
    // Filtrar categorías no deseadas
    const excludedCategories = ['Item ID (auto generated)', 'Item ID (autogenerated)', 'Item ID', 'ID'];
    
    const data = Object.entries(summary.byCategory)
      .filter(([category]) => !excludedCategories.includes(category))
      .map(([category, data]) => ({
        name: CATEGORY_SHORT_NAMES[category] || category,
        fullName: category,
        ok: data.ok,
        no: data.no,
        na: data.na,
        complianceRate: parseFloat(data.complianceRate)
      }));
    
    return data;
  };

  const preparePieData = () => {
    if (!summary) {
      console.log('No hay datos de resumen disponibles para el gráfico circular');
      return [];
    }
    
    // Excluir N/A del gráfico circular
    const data = [
      { name: 'Cumplimiento', value: summary.okCount },
      { name: 'Incumplimiento', value: summary.noCount }
    ];
    
    return data;
  };

  // Preparar datos para la tendencia diaria
  const prepareTrendData = () => {
    if (!summary || !summary.trend || !Array.isArray(summary.trend) || summary.trend.length === 0) {
      console.log('No hay datos de tendencia disponibles');
      return [];
    }
    
    // Obtener el rango de fechas actual
    const { startDate, endDate } = calculateDateRange(period);
    
    console.log('Datos de tendencia originales:', summary.trend);
    console.log('Rango de fechas:', startDate, endDate);
    
    // Filtrar por el período seleccionado y asegurarse de que los datos son válidos
    const filteredTrend = summary.trend.filter(item => {
      if (!item || !item.date) {
        console.log('Item inválido (sin fecha):', item);
        return false;
      }
      
      // Verificar si la fecha está en el rango
      const inRange = item.date >= startDate && item.date <= endDate;
      if (!inRange) {
        console.log('Fecha fuera de rango:', item.date, startDate, endDate);
      }
      
      // Verificar si la tasa de cumplimiento es válida
      const validRate = !isNaN(parseFloat(item.complianceRate));
      if (!validRate) {
        console.log('Tasa de cumplimiento inválida:', item.complianceRate);
      }
      
      return inRange && validRate;
    });
    
    console.log('Datos filtrados por período:', filteredTrend);
    
    // Si no hay datos después del filtrado, intentar usar todos los datos disponibles
    if (filteredTrend.length === 0 && period === 'week') {
      console.log('No hay datos para la última semana, mostrando todos los datos disponibles');
      return summary.trend
        .filter(item => item && item.date && !isNaN(parseFloat(item.complianceRate)))
        .sort((a, b) => new Date(a.date) - new Date(b.date))
        .map(item => ({
          ...item,
          formattedDate: formatDate(item.date)
        }));
    }
    
    // Ordenar por fecha
    const sortedTrend = [...filteredTrend].sort((a, b) => 
      new Date(a.date) - new Date(b.date)
    );
    
    console.log('Datos de tendencia procesados y ordenados:', sortedTrend);
    
    // Formatear fechas para mostrar en el gráfico
    return sortedTrend.map(item => ({
      ...item,
      formattedDate: formatDate(item.date)
    }));
  };

  // Determinar el color de la barra según la tasa de cumplimiento
  const getBarColor = (complianceRate) => {
    return complianceRate >= 96 ? '#4caf50' : '#f44336';
  };

  // Renderizar tooltip personalizado para mostrar el nombre completo de la categoría
  const CustomTooltip = ({ active, payload, label }) => {
    if (active && payload && payload.length) {
      const data = payload[0].payload;
      return (
        <div style={{ 
          backgroundColor: '#fff', 
          padding: '10px', 
          border: '1px solid #ccc',
          borderRadius: '4px',
          boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
        }}>
          <p style={{ margin: 0 }}><strong>Categoría:</strong> {data.fullName || data.name}</p>
          {payload.map((entry, index) => (
            <p key={index} style={{ margin: 0, color: entry.color }}>
              <strong>{entry.name}:</strong> {entry.name.includes('%') ? `${entry.value.toFixed(1)}%` : entry.value}
            </p>
          ))}
        </div>
      );
    }
    return null;
  };

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
        <CircularProgress />
      </Box>
    );
  }

  if (error) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="error" sx={{ mb: 2 }}>
          {error}
        </Alert>
        <Button variant="contained" onClick={loadData}>
          Reintentar
        </Button>
      </Box>
    );
  }

  // Si no hay datos, mostrar mensaje
  if (!summary || summary.totalRecords === 0) {
    return (
      <Box sx={{ p: 3 }}>
        <Alert severity="info" sx={{ mb: 2 }}>
          No hay datos disponibles para mostrar. Por favor, cargue archivos CSV con datos de KPI.
        </Alert>
      </Box>
    );
  }

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      {/* Selector de período */}
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Dashboard de KPIs Operativos
        </Typography>
        
        <FormControl sx={{ minWidth: 150 }}>
          <InputLabel>Período</InputLabel>
          <Select
            value={period}
            label="Período"
            onChange={handlePeriodChange}
          >
            <MenuItem value="week">Última semana</MenuItem>
            <MenuItem value="month">Último mes</MenuItem>
            <MenuItem value="quarter">Último trimestre</MenuItem>
            <MenuItem value="year">Último año</MenuItem>
          </Select>
        </FormControl>
      </Box>
      
      <Divider sx={{ mb: 3 }} />
      
      {/* Panel principal */}
      <Grid container spacing={3}>
        {/* Tarjetas de KPI */}
        {visibleWidgets.kpiCards && (
          <Grid item xs={12}>
            <Grid container spacing={3}>
              <Grid item xs={12} sm={6} md={3}>
                <KPICard
                  title="Tasa de Cumplimiento"
                  value={summary ? `${summary.complianceRate}%` : '0%'}
                  icon="compliance"
                  color="#4caf50"
                />
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <KPICard
                  title="Total Registros"
                  value={summary ? summary.totalRecords : 0}
                  icon="total"
                  color="#2196f3"
                />
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <KPICard
                  title="Cumplimientos"
                  value={summary ? summary.okCount : 0}
                  icon="check"
                  color="#8bc34a"
                />
              </Grid>
              <Grid item xs={12} sm={6} md={3}>
                <KPICard
                  title="Incumplimientos"
                  value={summary ? summary.noCount : 0}
                  icon="error"
                  color="#f44336"
                />
              </Grid>
            </Grid>
          </Grid>
        )}
        
        {/* Gráfico de tendencias */}
        {visibleWidgets.trendChart && (
          <Grid item xs={12} md={8}>
            <Paper sx={{ p: 2, height: 400 }}>
              <Typography variant="h6" gutterBottom>
                Tendencia de Cumplimiento ({period === 'week' ? 'Última semana' : 
                                           period === 'month' ? 'Último mes' : 
                                           period === 'quarter' ? 'Último trimestre' : 'Último año'})
              </Typography>
              {prepareTrendData().length > 0 ? (
                <ResponsiveContainer width="100%" height="90%">
                  <LineChart
                    data={prepareTrendData()}
                    margin={{ top: 5, right: 30, left: 20, bottom: 30 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis 
                      dataKey="formattedDate" 
                      angle={-45} 
                      textAnchor="end" 
                      height={70}
                      interval={period === 'quarter' ? 7 : 0}  // Mostrar cada 7 días para trimestre
                    />
                    <YAxis 
                      domain={[0, 100]} 
                      ticks={[0, 20, 40, 60, 80, 96, 100]}
                    />
                    <Tooltip 
                      formatter={(value, name) => [
                        name === "complianceRate" ? `${value.toFixed(2)}%` : value, 
                        name === "complianceRate" ? "Tasa de Cumplimiento" : name
                      ]}
                      labelFormatter={(label) => `Fecha: ${label}`}
                    />
                    <Legend />
                    <ReferenceLine y={96} stroke="green" strokeDasharray="3 3" label="Meta 96%" />
                    <Line
                      type="monotone"
                      dataKey="complianceRate"
                      name="Tasa de Cumplimiento"
                      stroke={theme.palette.primary.main}
                      activeDot={{ r: 8 }}
                      label={{
                        position: 'top',
                        formatter: (value) => `${value.toFixed(1)}%`,
                        fontSize: 12
                      }}
                    />
                  </LineChart>
                </ResponsiveContainer>
              ) : (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '90%' }}>
                  <Typography color="text.secondary">No hay datos de tendencia disponibles para el período seleccionado</Typography>
                </Box>
              )}
            </Paper>
          </Grid>
        )}
        
        {/* Gráfico circular */}
        {visibleWidgets.pieChart && (
          <Grid item xs={12} md={4}>
            <Paper sx={{ p: 2, height: 400 }}>
              <Typography variant="h6" gutterBottom>
                Distribución de Estados
              </Typography>
              {preparePieData().length > 0 ? (
                <ResponsiveContainer width="100%" height="90%">
                  <PieChart>
                    <Pie
                      data={preparePieData()}
                      cx="50%"
                      cy="50%"
                      labelLine={false}
                      outerRadius={80}
                      fill="#8884d8"
                      dataKey="value"
                      label={({ name, percent }) => `${name}: ${(percent * 100).toFixed(0)}%`}
                    >
                      {preparePieData().map((entry, index) => (
                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip formatter={(value) => value} />
                    <Legend />
                  </PieChart>
                </ResponsiveContainer>
              ) : (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '90%' }}>
                  <Typography color="text.secondary">No hay datos para el gráfico circular</Typography>
                </Box>
              )}
            </Paper>
          </Grid>
        )}
        
        {/* Gráfico de barras */}
        {visibleWidgets.barChart && (
          <Grid item xs={12}>
            <Paper sx={{ p: 2, height: 600 }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Incidencias por Categoría
                </Typography>
                <FormControl sx={{ minWidth: 150 }}>
                  <InputLabel size="small">Período</InputLabel>
                  <Select
                    value={period}
                    label="Período"
                    onChange={handlePeriodChange}
                    size="small"
                  >
                    <MenuItem value="week">Última semana</MenuItem>
                    <MenuItem value="month">Último mes</MenuItem>
                    <MenuItem value="quarter">Último trimestre</MenuItem>
                    <MenuItem value="year">Último año</MenuItem>
                  </Select>
                </FormControl>
              </Box>
              {prepareCategoryData().length > 0 ? (
                <ResponsiveContainer width="100%" height="90%">
                  <BarChart
                    data={prepareCategoryData()}
                    layout="vertical"
                    margin={{ top: 5, right: 30, left: 150, bottom: 5 }}
                  >
                    <CartesianGrid strokeDasharray="3 3" />
                    <XAxis type="number" />
                    <YAxis 
                      type="category" 
                      dataKey="name" 
                      width={140}
                      tick={{ fontSize: 12 }}
                    />
                    <Tooltip content={<CustomTooltip />} />
                    <Legend />
                    <Bar dataKey="ok" name="Cumplimiento" fill="#4caf50" barSize={30} />
                    <Bar dataKey="no" name="Incumplimiento" fill="#f44336" barSize={30} />
                  </BarChart>
                </ResponsiveContainer>
              ) : (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '90%' }}>
                  <Typography color="text.secondary">No hay datos para el gráfico de barras</Typography>
                </Box>
              )}
            </Paper>
          </Grid>
        )}
        
        {/* Tasa de Cumplimiento por Categoría */}
        <Grid item xs={12}>
          <Paper sx={{ p: 2, height: 600 }}>
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
              <Typography variant="h6">
                Tasa de Cumplimiento por Categoría
              </Typography>
              <FormControl sx={{ minWidth: 150 }}>
                <InputLabel size="small">Período</InputLabel>
                <Select
                  value={period}
                  label="Período"
                  onChange={handlePeriodChange}
                  size="small"
                >
                  <MenuItem value="week">Última semana</MenuItem>
                  <MenuItem value="month">Último mes</MenuItem>
                  <MenuItem value="quarter">Último trimestre</MenuItem>
                  <MenuItem value="year">Último año</MenuItem>
                </Select>
              </FormControl>
            </Box>
            {prepareCategoryData().length > 0 ? (
              <ResponsiveContainer width="100%" height="90%">
                <BarChart
                  data={prepareCategoryData()}
                  layout="vertical"
                  margin={{ top: 5, right: 60, left: 150, bottom: 5 }}
                >
                  <CartesianGrid strokeDasharray="3 3" />
                  <XAxis 
                    type="number" 
                    domain={[0, 100]}
                  />
                  <YAxis 
                    type="category" 
                    dataKey="name" 
                    width={140}
                    tick={{ fontSize: 12 }}
                  />
                  <Tooltip content={<CustomTooltip />} />
                  <Legend />
                  <ReferenceLine x={96} stroke="green" strokeDasharray="3 3" label="Meta 96%" />
                  <Bar
                    dataKey="complianceRate"
                    name="Tasa de Cumplimiento (%)"
                    fill={theme.palette.primary.main}
                    barSize={30}
                    shape={(props) => {
                      return (
                        <rect
                          x={props.x}
                          y={props.y}
                          width={props.width}
                          height={props.height}
                          fill={getBarColor(props.payload.complianceRate)}
                          radius={[0, 0, 0, 0]}
                        />
                      );
                    }}
                  >
                    <LabelList 
                      dataKey="complianceRate" 
                      position="right" 
                      formatter={(value) => `${value.toFixed(1)}%`}
                    />
                  </Bar>
                </BarChart>
              </ResponsiveContainer>
            ) : (
              <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '90%' }}>
                <Typography color="text.secondary">No hay datos de categoría disponibles</Typography>
              </Box>
            )}
          </Paper>
        </Grid>
        
        {/* Listado de comentarios únicos */}
        {visibleWidgets.heatmap && (
          <Grid item xs={12}>
            <Paper sx={{ p: 2, height: 400, overflow: 'auto' }}>
              <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 2 }}>
                <Typography variant="h6">
                  Comentarios Registrados (Más recientes primero)
                </Typography>
                <FormControl sx={{ minWidth: 150 }}>
                  <InputLabel size="small">Período</InputLabel>
                  <Select
                    value={period}
                    label="Período"
                    onChange={handlePeriodChange}
                    size="small"
                  >
                    <MenuItem value="week">Última semana</MenuItem>
                    <MenuItem value="month">Último mes</MenuItem>
                    <MenuItem value="quarter">Último trimestre</MenuItem>
                    <MenuItem value="year">Último año</MenuItem>
                  </Select>
                </FormControl>
              </Box>
              {summary && summary.uniqueErrors && summary.uniqueErrors.length > 0 ? (
                <Box>
                  {summary.uniqueErrors.map((comment, index) => {
                    // Extraer la fecha y el texto del comentario
                    let date = '';
                    let commentText = comment;
                    
                    if (comment.startsWith('[') && comment.includes(']')) {
                      const parts = comment.split(']');
                      date = parts[0].substring(1);
                      commentText = parts[1].trim();
                    }
                    
                    // No mostrar comentarios vacíos
                    if (!commentText || commentText.trim() === '') {
                      return null;
                    }
                    
                    // Determinar la severidad basada en el contenido
                    const severity = commentText.toLowerCase().includes('error') || 
                                    commentText.toLowerCase().includes('problema') || 
                                    commentText.toLowerCase().includes('falla') || 
                                    commentText.toLowerCase().includes('no ') ? 
                                    "warning" : "info";
                    
                    return (
                      <Alert 
                        key={index} 
                        severity={severity}
                        sx={{ mb: 1 }}
                        variant="outlined"
                      >
                        {date && (
                          <strong style={{ marginRight: '8px' }}>{date}:</strong>
                        )}
                        {commentText}
                      </Alert>
                    );
                  }).filter(item => item !== null)}
                </Box>
              ) : (
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '90%' }}>
                  <Typography color="text.secondary">No hay comentarios registrados</Typography>
                </Box>
              )}
            </Paper>
          </Grid>
        )}
      </Grid>
      
      {/* Botón para recargar datos */}
      <Box sx={{ mt: 3, display: 'flex', justifyContent: 'center' }}>
        <Button 
          variant="contained" 
          onClick={loadData}
          startIcon={<span role="img" aria-label="refresh">🔄</span>}
        >
          Actualizar datos
        </Button>
      </Box>
    </Box>
  );
};

export default Dashboard;