import { getAuthHeaders } from './authService';

// Almacenamiento local para los archivos CSV
let uploadedFiles = [{
  key: `default-DEV_Workload_1_DATOS.csv`,
  name: 'DEV_Workload_1_DATOS.csv',
  size: 1024,
  lastModified: new Date().toISOString()
}];

let processedData = {
  totalRecords: 0,
  okCount: 0,
  noCount: 0,
  naCount: 0,
  complianceRate: "0",
  byCategory: {},
  byDate: {},
  trend: [],
  uniqueErrors: []
};

// Cargar automáticamente el archivo CSV al iniciar
(async function() {
  try {
    console.log('Cargando automáticamente el archivo CSV predeterminado...');
    const response = await fetch('/DEV_Workload_1_DATOS.csv');
    const csvText = await response.text();
    const blob = new Blob([csvText], { type: 'text/csv' });
    const file = new File([blob], 'DEV_Workload_1_DATOS.csv', { type: 'text/csv' });
    
    // Procesar el archivo
    await processCSV(file);
    console.log('Archivo CSV predeterminado cargado y procesado correctamente');
  } catch (error) {
    console.error('Error al cargar el archivo CSV predeterminado:', error);
  }
})();

/**
 * Procesa un archivo CSV
 * @param {File} file - Archivo CSV a procesar
 * @returns {Promise} - Promesa con los datos procesados
 */
const processCSV = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (event) => {
      try {
        const csvData = event.target.result;
        const lines = csvData.split('\n');
        const headers = lines[0].split(',');
        
        console.log("Headers detectados:", headers);
        
        // Encontrar índices de columnas importantes
        const nameIndex = headers.findIndex(h => h.trim().toLowerCase() === 'name');
        const commentIndex = headers.findIndex(h => h.trim().toLowerCase() === 'commentario');
        
        console.log(`Índice de columna Name: ${nameIndex}, Índice de columna Commentario: ${commentIndex}`);
        
        // Normalizar nombres de categorías para comparación
        const normalizeCategory = (name) => {
          return name.trim().toLowerCase().replace(/\s+/g, ' ');
        };
        
        // Mapeo de nombres de categorías a nombres normalizados
        const CATEGORY_MAPPING = {
          'operativo anual': 'Operativo Anual',
          'operativo fin de semana y semanal': 'Operativo Fin de Semana y Semanal',
          'op. semanal': 'Operativo Fin de Semana y Semanal',
          'op. anual': 'Operativo Anual'
        };
        
        // Filtrar columnas no deseadas con mejor normalización
        const excludedColumns = ['name', 'commentario', 'item id (autogenerated)', 'item id', 'id'];
        const validCategories = headers.map((header, index) => {
          const normalizedHeader = normalizeCategory(header);
          
          // Excluir columnas específicas
          if (excludedColumns.includes(normalizedHeader)) {
            console.log(`Excluyendo columna: ${header}`);
            return null;
          }
          
          // Usar nombre normalizado o mapeo si existe
          const displayName = CATEGORY_MAPPING[normalizedHeader] || header.trim();
          return { index, name: displayName, originalName: header.trim() };
        }).filter(item => item !== null);
        
        console.log("Categorías válidas:", validCategories.map(c => `${c.name} (índice ${c.index})`));
        
        // Inicializar contadores
        let okCount = 0;
        let noCount = 0;
        let naCount = 0;
        const byCategory = {};
        const byDate = {};
        const trend = [];
        const uniqueErrors = [];
        
        // Inicializar todas las categorías
        validCategories.forEach(category => {
          byCategory[category.name] = { ok: 0, no: 0, na: 0, complianceRate: "0" };
        });
        
        console.log("Categorías inicializadas:", Object.keys(byCategory));
        
        // Procesar cada línea
        for (let i = 1; i < lines.length; i++) {
          if (!lines[i].trim()) continue;
          
          const values = lines[i].split(',');
          const date = values[nameIndex];
          const comment = commentIndex >= 0 ? values[commentIndex] : '';
          
          // console.log(`Procesando línea ${i}: Fecha=${date}, Valores totales=${values.length}`);
          
          // Procesar cada categoría válida
          validCategories.forEach(category => {
            const value = values[category.index]?.trim().toUpperCase();
            // console.log(`  Categoría: ${category.name}, Valor: ${value}`);
            
            if (value === 'OK') {
              okCount++;
              byCategory[category.name].ok++;
            } else if (value === 'NO') {
              noCount++;
              byCategory[category.name].no++;
            } else if (value === 'N/A') {
              naCount++;
              byCategory[category.name].na++;
            }
          });
          
          // Procesar fecha
          const dateParts = date.split('/');
          if (dateParts.length === 3) {
            const isoDate = `${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`;
            
            // Inicializar fecha si no existe
            if (!byDate[isoDate]) {
              byDate[isoDate] = { ok: 0, no: 0, na: 0, complianceRate: "0" };
            }
            
            // Actualizar contadores por fecha sumando todos los valores de esta línea
            validCategories.forEach(category => {
              const value = values[category.index]?.trim().toUpperCase();
              if (value === 'OK') {
                byDate[isoDate].ok++;
              } else if (value === 'NO') {
                byDate[isoDate].no++;
              } else if (value === 'N/A') {
                byDate[isoDate].na++;
              }
            });
            
            // Calcular tasa de cumplimiento por fecha
            const total = byDate[isoDate].ok + byDate[isoDate].no;
            byDate[isoDate].complianceRate = total > 0 ? 
              ((byDate[isoDate].ok / total) * 100).toFixed(2) : "0";
            
            // Añadir a tendencia
            trend.push({
              date: isoDate,
              complianceRate: parseFloat(byDate[isoDate].complianceRate),
              ok: byDate[isoDate].ok,
              no: byDate[isoDate].no,
              na: byDate[isoDate].na
            });
          }
          
          // Procesar comentario
          if (comment && !uniqueErrors.includes(`[${date}] ${comment}`)) {
            uniqueErrors.push(`[${date}] ${comment}`);
          }
        }
        
        // Calcular tasas de cumplimiento por categoría
        Object.keys(byCategory).forEach(category => {
          const total = byCategory[category].ok + byCategory[category].no;
          byCategory[category].complianceRate = total > 0 ? 
            ((byCategory[category].ok / total) * 100).toFixed(2) : "0";
          console.log(`Categoría ${category}: OK=${byCategory[category].ok}, NO=${byCategory[category].no}, Tasa=${byCategory[category].complianceRate}%`);
        });
        
        // Calcular tasa de cumplimiento general
        const total = okCount + noCount;
        const complianceRate = total > 0 ? ((okCount / total) * 100).toFixed(2) : "0";
        
        // Eliminar categorías no deseadas explícitamente
        delete byCategory['Item ID (auto generated)'];
        delete byCategory['Item ID (autogenerated)'];
        delete byCategory['Item ID'];
        
        // Actualizar datos procesados
        processedData = {
          totalRecords: lines.length - 1,
          okCount,
          noCount,
          naCount,
          complianceRate,
          byCategory,
          byDate,
          trend,
          uniqueErrors
        };
        
        console.log("Resumen de datos procesados:");
        console.log(`Total registros: ${processedData.totalRecords}`);
        console.log(`OK: ${okCount}, NO: ${noCount}, N/A: ${naCount}`);
        console.log(`Tasa de cumplimiento: ${complianceRate}%`);
        console.log(`Categorías procesadas: ${Object.keys(byCategory).length}`);
        console.log(`Fechas procesadas: ${Object.keys(byDate).length}`);
        
        resolve(processedData);
      } catch (error) {
        console.error('Error al procesar CSV:', error);
        reject(error);
      }
    };
    
    reader.onerror = (error) => {
      console.error('Error al leer el archivo:', error);
      reject(error);
    };
    
    reader.readAsText(file);
  });
};

/**
 * Sube un archivo CSV
 * @param {File} file - Archivo CSV a subir
 * @returns {Promise} - Promesa con la respuesta
 */
export const uploadCSV = async (file) => {
  try {
    console.log(`Procesando archivo CSV localmente: ${file.name}`);
    
    // Procesar el archivo
    await processCSV(file);
    
    // Guardar el archivo en la lista
    const fileInfo = {
      key: `${Date.now()}-${file.name}`,
      name: file.name,
      size: file.size,
      lastModified: new Date().toISOString()
    };
    
    uploadedFiles.push(fileInfo);
    
    return {
      success: true,
      message: `Archivo ${file.name} procesado correctamente`,
      file: fileInfo
    };
  } catch (error) {
    console.error('Error al procesar archivo CSV:', error);
    throw error;
  }
};

/**
 * Obtiene la lista de archivos CSV
 * @returns {Promise} - Promesa con la lista de archivos
 */
export const getCSVFiles = async () => {
  return {
    files: uploadedFiles
  };
};

/**
 * Obtiene una vista previa de un archivo CSV
 * @param {string} key - Clave del archivo
 * @returns {Promise} - Promesa con la vista previa
 */
export const getCSVPreview = async (key) => {
  const file = uploadedFiles.find(f => f.key === key);
  
  if (!file) {
    throw new Error('Archivo no encontrado');
  }
  
  return {
    preview: [
      "Name,Ventas por Tienda,Ventas Presidencia,Operativo Diario,Commentario",
      "01/05/2023,OK,OK,NO,Comentario de prueba",
      "02/05/2023,OK,NO,OK,",
      "03/05/2023,NO,OK,OK,Otro comentario"
    ]
  };
};

/**
 * Elimina un archivo CSV
 * @param {string} key - Clave del archivo
 * @returns {Promise} - Promesa con la respuesta
 */
export const deleteCSVFile = async (key) => {
  const index = uploadedFiles.findIndex(f => f.key === key);
  
  if (index === -1) {
    throw new Error('Archivo no encontrado');
  }
  
  uploadedFiles.splice(index, 1);
  
  return {
    success: true,
    message: `Archivo eliminado correctamente`
  };
};

/**
 * Obtiene los datos de KPI
 */
export const getKPIData = async () => {
  return {
    data: processedData.trend
  };
};

/**
 * Obtiene el resumen de KPIs
 */
export const getKPISummary = async () => {
  return {
    summary: processedData
  };
};

// Exportar el servicio completo
export const localCsvService = {
  uploadCSV,
  getCSVFiles,
  getCSVPreview,
  deleteCSVFile,
  getKPIData,
  getKPISummary
};